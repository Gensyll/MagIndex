// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using MagIndex_Library;
//
//    var mtgCard = MtgCard.FromJson(jsonString);

namespace MagIndex_Library
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using System.Text;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class MtgCard
    {
        [JsonProperty("colorIdentity")]
        public List<Color> ColorIdentity { get; set; }

        [JsonProperty("colors")]
        public List<Color> Colors { get; set; }

        [JsonProperty("convertedManaCost")]
        public double ConvertedManaCost { get; set; }

        [JsonProperty("foreignData")]
        public List<ForeignDatum> ForeignData { get; set; }

        [JsonProperty("layout")]
        public Layout Layout { get; set; }

        [JsonProperty("legalities")]
        public Legalities Legalities { get; set; }

        [JsonProperty("manaCost", NullValueHandling = NullValueHandling.Ignore)]
        public string ManaCost { get; set; }

        [JsonProperty("mtgstocksId", NullValueHandling = NullValueHandling.Ignore)]
        public long? MtgstocksId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("printings")]
        public List<string> Printings { get; set; }

        [JsonProperty("purchaseUrls", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseUrls PurchaseUrls { get; set; }

        [JsonProperty("rulings")]
        public List<Ruling> Rulings { get; set; }

        [JsonProperty("scryfallOracleId")]
        public Guid ScryfallOracleId { get; set; }

        [JsonProperty("subtypes")]
        public List<string> Subtypes { get; set; }

        [JsonProperty("supertypes")]
        public List<Supertype> Supertypes { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("types")]
        public List<TypeElement> Types { get; set; }

        [JsonProperty("uuid")]
        public Guid Uuid { get; set; }

        [JsonProperty("edhrecRank", NullValueHandling = NullValueHandling.Ignore)]
        public long? EdhrecRank { get; set; }

        [JsonProperty("mtgoFoilId", NullValueHandling = NullValueHandling.Ignore)]
        public long? MtgoFoilId { get; set; }

        [JsonProperty("mtgoId", NullValueHandling = NullValueHandling.Ignore)]
        public long? MtgoId { get; set; }

        [JsonProperty("mtgArenaId", NullValueHandling = NullValueHandling.Ignore)]
        public long? MtgArenaId { get; set; }

        [JsonProperty("power", NullValueHandling = NullValueHandling.Ignore)]
        public string Power { get; set; }

        [JsonProperty("toughness", NullValueHandling = NullValueHandling.Ignore)]
        public string Toughness { get; set; }

        [JsonProperty("faceConvertedManaCost", NullValueHandling = NullValueHandling.Ignore)]
        public long? FaceConvertedManaCost { get; set; }

        [JsonProperty("names", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Names { get; set; }

        [JsonProperty("side", NullValueHandling = NullValueHandling.Ignore)]
        public Side? Side { get; set; }

        [JsonProperty("isReserved", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsReserved { get; set; }

        [JsonProperty("leadershipSkills", NullValueHandling = NullValueHandling.Ignore)]
        public LeadershipSkills LeadershipSkills { get; set; }

        [JsonProperty("loyalty", NullValueHandling = NullValueHandling.Ignore)]
        public string Loyalty { get; set; }

        [JsonProperty("hand", NullValueHandling = NullValueHandling.Ignore)]
        public string Hand { get; set; }

        [JsonProperty("life", NullValueHandling = NullValueHandling.Ignore)]
        public string Life { get; set; }

        [JsonProperty("colorIndicator", NullValueHandling = NullValueHandling.Ignore)]
        public List<Color> ColorIndicator { get; set; }

        [JsonProperty("hasNoDeckLimit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasNoDeckLimit { get; set; }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine($"Card: {Name} - {ManaCost} ({Power}/{Toughness})");
            sb.AppendLine($"Type: {Type}");
            sb.AppendLine($"Text: ---");
            if (Text != null)
            {
                for (int i = 0; i < Text.Length; ++i)
                {
                    sb.Append(Text[i]);
                    if (i % 100 == 0 && i != 0) sb.AppendLine();
                }
            }
            return sb.ToString();
        }
    }

        public partial class ForeignDatum
    {
        [JsonProperty("language")]
        public Language Language { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("flavorText", NullValueHandling = NullValueHandling.Ignore)]
        public string FlavorText { get; set; }
    }

    public partial class LeadershipSkills
    {
        [JsonProperty("brawl")]
        public bool Brawl { get; set; }

        [JsonProperty("commander")]
        public bool Commander { get; set; }

        [JsonProperty("oathbreaker")]
        public bool Oathbreaker { get; set; }
    }

    public partial class Legalities
    {
        [JsonProperty("future", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Future { get; set; }

        [JsonProperty("commander", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Commander { get; set; }

        [JsonProperty("duel", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Duel { get; set; }

        [JsonProperty("legacy", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Legacy { get; set; }

        [JsonProperty("penny", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Penny { get; set; }

        [JsonProperty("vintage", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Vintage { get; set; }

        [JsonProperty("modern", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Modern { get; set; }

        [JsonProperty("pauper", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Pauper { get; set; }

        [JsonProperty("brawl", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Brawl { get; set; }

        [JsonProperty("standard", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Standard { get; set; }

        [JsonProperty("oldschool", NullValueHandling = NullValueHandling.Ignore)]
        public Brawl? Oldschool { get; set; }
    }

    public partial class PurchaseUrls
    {
        [JsonProperty("cardmarket", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Cardmarket { get; set; }

        [JsonProperty("mtgstocks", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Mtgstocks { get; set; }

        [JsonProperty("tcgplayer", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Tcgplayer { get; set; }
    }

    public partial class Ruling
    {
        [JsonProperty("date")]
        public DateTimeOffset Date { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }
    }

    public enum Color { B, G, R, U, W };

    public enum Language { ChineseSimplified, ChineseTraditional, French, German, Italian, Japanese, Korean, PortugueseBrazil, Russian, Spanish };

    public enum Layout { Adventure, Aftermath, Augment, Flip, Host, Leveler, Meld, Normal, Planar, Saga, Scheme, Split, Transform, Vanguard };

    public enum Brawl { Banned, Legal, Restricted };

    public enum Side { A, B, C };

    public enum Supertype { Basic, Host, Legendary, Ongoing, Snow, World };

    public enum TypeElement { Artifact, Conspiracy, Creature, Eaturecray, Enchantment, Ever, Hero, Instant, Land, Phenomenon, Plane, Planeswalker, Scariest, Scheme, See, Sorcery, Summon, Tribal, TypeInstant, Vanguard, YouLl };

    public partial class MtgCard
    {
        public static Dictionary<string, MtgCard> FromJson(string json) => JsonConvert.DeserializeObject<Dictionary<string, MtgCard>>(json, MagIndex_Library.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Dictionary<string, MtgCard> self) => JsonConvert.SerializeObject(self, MagIndex_Library.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ColorConverter.Singleton,
                LanguageConverter.Singleton,
                LayoutConverter.Singleton,
                BrawlConverter.Singleton,
                SideConverter.Singleton,
                SupertypeConverter.Singleton,
                TypeElementConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Color) || t == typeof(Color?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "B":
                    return Color.B;
                case "G":
                    return Color.G;
                case "R":
                    return Color.R;
                case "U":
                    return Color.U;
                case "W":
                    return Color.W;
            }
            throw new Exception("Cannot unmarshal type Color");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Color)untypedValue;
            switch (value)
            {
                case Color.B:
                    serializer.Serialize(writer, "B");
                    return;
                case Color.G:
                    serializer.Serialize(writer, "G");
                    return;
                case Color.R:
                    serializer.Serialize(writer, "R");
                    return;
                case Color.U:
                    serializer.Serialize(writer, "U");
                    return;
                case Color.W:
                    serializer.Serialize(writer, "W");
                    return;
            }
            throw new Exception("Cannot marshal type Color");
        }

        public static readonly ColorConverter Singleton = new ColorConverter();
    }

    internal class LanguageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Language) || t == typeof(Language?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Chinese Simplified":
                    return Language.ChineseSimplified;
                case "Chinese Traditional":
                    return Language.ChineseTraditional;
                case "French":
                    return Language.French;
                case "German":
                    return Language.German;
                case "Italian":
                    return Language.Italian;
                case "Japanese":
                    return Language.Japanese;
                case "Korean":
                    return Language.Korean;
                case "Portuguese (Brazil)":
                    return Language.PortugueseBrazil;
                case "Russian":
                    return Language.Russian;
                case "Spanish":
                    return Language.Spanish;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Language)untypedValue;
            switch (value)
            {
                case Language.ChineseSimplified:
                    serializer.Serialize(writer, "Chinese Simplified");
                    return;
                case Language.ChineseTraditional:
                    serializer.Serialize(writer, "Chinese Traditional");
                    return;
                case Language.French:
                    serializer.Serialize(writer, "French");
                    return;
                case Language.German:
                    serializer.Serialize(writer, "German");
                    return;
                case Language.Italian:
                    serializer.Serialize(writer, "Italian");
                    return;
                case Language.Japanese:
                    serializer.Serialize(writer, "Japanese");
                    return;
                case Language.Korean:
                    serializer.Serialize(writer, "Korean");
                    return;
                case Language.PortugueseBrazil:
                    serializer.Serialize(writer, "Portuguese (Brazil)");
                    return;
                case Language.Russian:
                    serializer.Serialize(writer, "Russian");
                    return;
                case Language.Spanish:
                    serializer.Serialize(writer, "Spanish");
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class LayoutConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Layout) || t == typeof(Layout?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "adventure":
                    return Layout.Adventure;
                case "aftermath":
                    return Layout.Aftermath;
                case "augment":
                    return Layout.Augment;
                case "flip":
                    return Layout.Flip;
                case "host":
                    return Layout.Host;
                case "leveler":
                    return Layout.Leveler;
                case "meld":
                    return Layout.Meld;
                case "normal":
                    return Layout.Normal;
                case "planar":
                    return Layout.Planar;
                case "saga":
                    return Layout.Saga;
                case "scheme":
                    return Layout.Scheme;
                case "split":
                    return Layout.Split;
                case "transform":
                    return Layout.Transform;
                case "vanguard":
                    return Layout.Vanguard;
            }
            throw new Exception("Cannot unmarshal type Layout");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Layout)untypedValue;
            switch (value)
            {
                case Layout.Adventure:
                    serializer.Serialize(writer, "adventure");
                    return;
                case Layout.Aftermath:
                    serializer.Serialize(writer, "aftermath");
                    return;
                case Layout.Augment:
                    serializer.Serialize(writer, "augment");
                    return;
                case Layout.Flip:
                    serializer.Serialize(writer, "flip");
                    return;
                case Layout.Host:
                    serializer.Serialize(writer, "host");
                    return;
                case Layout.Leveler:
                    serializer.Serialize(writer, "leveler");
                    return;
                case Layout.Meld:
                    serializer.Serialize(writer, "meld");
                    return;
                case Layout.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
                case Layout.Planar:
                    serializer.Serialize(writer, "planar");
                    return;
                case Layout.Saga:
                    serializer.Serialize(writer, "saga");
                    return;
                case Layout.Scheme:
                    serializer.Serialize(writer, "scheme");
                    return;
                case Layout.Split:
                    serializer.Serialize(writer, "split");
                    return;
                case Layout.Transform:
                    serializer.Serialize(writer, "transform");
                    return;
                case Layout.Vanguard:
                    serializer.Serialize(writer, "vanguard");
                    return;
            }
            throw new Exception("Cannot marshal type Layout");
        }

        public static readonly LayoutConverter Singleton = new LayoutConverter();
    }

    internal class BrawlConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Brawl) || t == typeof(Brawl?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Banned":
                    return Brawl.Banned;
                case "Legal":
                    return Brawl.Legal;
                case "Restricted":
                    return Brawl.Restricted;
            }
            throw new Exception("Cannot unmarshal type Brawl");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Brawl)untypedValue;
            switch (value)
            {
                case Brawl.Banned:
                    serializer.Serialize(writer, "Banned");
                    return;
                case Brawl.Legal:
                    serializer.Serialize(writer, "Legal");
                    return;
                case Brawl.Restricted:
                    serializer.Serialize(writer, "Restricted");
                    return;
            }
            throw new Exception("Cannot marshal type Brawl");
        }

        public static readonly BrawlConverter Singleton = new BrawlConverter();
    }

    internal class SideConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Side) || t == typeof(Side?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "a":
                    return Side.A;
                case "b":
                    return Side.B;
                case "c":
                    return Side.C;
            }
            throw new Exception("Cannot unmarshal type Side");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Side)untypedValue;
            switch (value)
            {
                case Side.A:
                    serializer.Serialize(writer, "a");
                    return;
                case Side.B:
                    serializer.Serialize(writer, "b");
                    return;
                case Side.C:
                    serializer.Serialize(writer, "c");
                    return;
            }
            throw new Exception("Cannot marshal type Side");
        }

        public static readonly SideConverter Singleton = new SideConverter();
    }

    internal class SupertypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Supertype) || t == typeof(Supertype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Basic":
                    return Supertype.Basic;
                case "Host":
                    return Supertype.Host;
                case "Legendary":
                    return Supertype.Legendary;
                case "Ongoing":
                    return Supertype.Ongoing;
                case "Snow":
                    return Supertype.Snow;
                case "World":
                    return Supertype.World;
            }
            throw new Exception("Cannot unmarshal type Supertype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Supertype)untypedValue;
            switch (value)
            {
                case Supertype.Basic:
                    serializer.Serialize(writer, "Basic");
                    return;
                case Supertype.Host:
                    serializer.Serialize(writer, "Host");
                    return;
                case Supertype.Legendary:
                    serializer.Serialize(writer, "Legendary");
                    return;
                case Supertype.Ongoing:
                    serializer.Serialize(writer, "Ongoing");
                    return;
                case Supertype.Snow:
                    serializer.Serialize(writer, "Snow");
                    return;
                case Supertype.World:
                    serializer.Serialize(writer, "World");
                    return;
            }
            throw new Exception("Cannot marshal type Supertype");
        }

        public static readonly SupertypeConverter Singleton = new SupertypeConverter();
    }

    internal class TypeElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeElement) || t == typeof(TypeElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Artifact":
                    return TypeElement.Artifact;
                case "Conspiracy":
                    return TypeElement.Conspiracy;
                case "Creature":
                    return TypeElement.Creature;
                case "Eaturecray":
                    return TypeElement.Eaturecray;
                case "Enchantment":
                    return TypeElement.Enchantment;
                case "Ever":
                    return TypeElement.Ever;
                case "Hero":
                    return TypeElement.Hero;
                case "Instant":
                    return TypeElement.Instant;
                case "Land":
                    return TypeElement.Land;
                case "Phenomenon":
                    return TypeElement.Phenomenon;
                case "Plane":
                    return TypeElement.Plane;
                case "Planeswalker":
                    return TypeElement.Planeswalker;
                case "Scariest":
                    return TypeElement.Scariest;
                case "Scheme":
                    return TypeElement.Scheme;
                case "See":
                    return TypeElement.See;
                case "Sorcery":
                    return TypeElement.Sorcery;
                case "Summon":
                    return TypeElement.Summon;
                case "Tribal":
                    return TypeElement.Tribal;
                case "Vanguard":
                    return TypeElement.Vanguard;
                case "You’ll":
                    return TypeElement.YouLl;
                case "instant":
                    return TypeElement.TypeInstant;
            }
            throw new Exception("Cannot unmarshal type TypeElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeElement)untypedValue;
            switch (value)
            {
                case TypeElement.Artifact:
                    serializer.Serialize(writer, "Artifact");
                    return;
                case TypeElement.Conspiracy:
                    serializer.Serialize(writer, "Conspiracy");
                    return;
                case TypeElement.Creature:
                    serializer.Serialize(writer, "Creature");
                    return;
                case TypeElement.Eaturecray:
                    serializer.Serialize(writer, "Eaturecray");
                    return;
                case TypeElement.Enchantment:
                    serializer.Serialize(writer, "Enchantment");
                    return;
                case TypeElement.Ever:
                    serializer.Serialize(writer, "Ever");
                    return;
                case TypeElement.Hero:
                    serializer.Serialize(writer, "Hero");
                    return;
                case TypeElement.Instant:
                    serializer.Serialize(writer, "Instant");
                    return;
                case TypeElement.Land:
                    serializer.Serialize(writer, "Land");
                    return;
                case TypeElement.Phenomenon:
                    serializer.Serialize(writer, "Phenomenon");
                    return;
                case TypeElement.Plane:
                    serializer.Serialize(writer, "Plane");
                    return;
                case TypeElement.Planeswalker:
                    serializer.Serialize(writer, "Planeswalker");
                    return;
                case TypeElement.Scariest:
                    serializer.Serialize(writer, "Scariest");
                    return;
                case TypeElement.Scheme:
                    serializer.Serialize(writer, "Scheme");
                    return;
                case TypeElement.See:
                    serializer.Serialize(writer, "See");
                    return;
                case TypeElement.Sorcery:
                    serializer.Serialize(writer, "Sorcery");
                    return;
                case TypeElement.Summon:
                    serializer.Serialize(writer, "Summon");
                    return;
                case TypeElement.Tribal:
                    serializer.Serialize(writer, "Tribal");
                    return;
                case TypeElement.Vanguard:
                    serializer.Serialize(writer, "Vanguard");
                    return;
                case TypeElement.YouLl:
                    serializer.Serialize(writer, "You’ll");
                    return;
                case TypeElement.TypeInstant:
                    serializer.Serialize(writer, "instant");
                    return;
            }
            throw new Exception("Cannot marshal type TypeElement");
        }

        public static readonly TypeElementConverter Singleton = new TypeElementConverter();
    }
}